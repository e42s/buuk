/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOltdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var waitUntil = ExtendableEvent.prototype.waitUntil;\n  var respondWith = FetchEvent.prototype.respondWith;\n  var promisesMap = new WeakMap();\n\n  ExtendableEvent.prototype.waitUntil = function (promise) {\n    var extendableEvent = this;\n    var promises = promisesMap.get(extendableEvent);\n\n    if (promises) {\n      promises.push(Promise.resolve(promise));\n      return;\n    }\n\n    promises = [Promise.resolve(promise)];\n    promisesMap.set(extendableEvent, promises);\n\n    // call original method\n    return waitUntil.call(extendableEvent, Promise.resolve().then(function processPromises() {\n      var len = promises.length;\n\n      // wait for all to settle\n      return Promise.all(promises.map(function (p) {\n        return p[\"catch\"](function () {});\n      })).then(function () {\n        // have new items been added? If so, wait again\n        if (promises.length != len) return processPromises();\n        // we're done!\n        promisesMap[\"delete\"](extendableEvent);\n        // reject if one of the promises rejected\n        return Promise.all(promises);\n      });\n    }));\n  };\n\n  FetchEvent.prototype.respondWith = function (promise) {\n    this.waitUntil(promise);\n    return respondWith.call(this, promise);\n  };\n})();;\n        'use strict';\n\nif (typeof DEBUG === 'undefined') {\n  var DEBUG = false;\n}\n\nfunction WebpackServiceWorker(params, helpers) {\n  var loaders = helpers.loaders;\n  var cacheMaps = helpers.cacheMaps;\n\n  var strategy = params.strategy;\n  var responseStrategy = params.responseStrategy;\n\n  var assets = params.assets;\n  var loadersMap = params.loaders || {};\n\n  var hashesMap = params.hashesMap;\n  var externals = params.externals;\n\n  // Not used yet\n  // const alwaysRevalidate = params.alwaysRevalidate;\n  // const ignoreSearch = params.ignoreSearch;\n  // const preferOnline = params.preferOnline;\n\n  var CACHE_PREFIX = params.name;\n  var CACHE_TAG = params.version;\n  var CACHE_NAME = CACHE_PREFIX + ':' + CACHE_TAG;\n\n  var STORED_DATA_KEY = '__offline_webpack__data';\n\n  mapAssets();\n\n  var allAssets = [].concat(assets.main, assets.additional, assets.optional);\n  var navigateFallbackURL = params.navigateFallbackURL;\n  var navigateFallbackForRedirects = params.navigateFallbackForRedirects;\n\n  self.addEventListener('install', function (event) {\n    console.log('[SW]:', 'Install event');\n\n    var installing = undefined;\n\n    if (strategy === 'changed') {\n      installing = cacheChanged('main');\n    } else {\n      installing = cacheAssets('main');\n    }\n\n    event.waitUntil(installing);\n  });\n\n  self.addEventListener('activate', function (event) {\n    console.log('[SW]:', 'Activate event');\n\n    var activation = cacheAdditional();\n\n    // Delete all assets which name starts with CACHE_PREFIX and\n    // is not current cache (CACHE_NAME)\n    activation = activation.then(storeCacheData);\n    activation = activation.then(deleteObsolete);\n    activation = activation.then(function () {\n      if (self.clients && self.clients.claim) {\n        return self.clients.claim();\n      }\n    });\n\n    event.waitUntil(activation);\n  });\n\n  function cacheAdditional() {\n    if (!assets.additional.length) {\n      return Promise.resolve();\n    }\n\n    if (DEBUG) {\n      console.log('[SW]:', 'Caching additional');\n    }\n\n    var operation = undefined;\n\n    if (strategy === 'changed') {\n      operation = cacheChanged('additional');\n    } else {\n      operation = cacheAssets('additional');\n    }\n\n    // Ignore fail of `additional` cache section\n    return operation['catch'](function (e) {\n      console.error('[SW]:', 'Cache section `additional` failed to load');\n    });\n  }\n\n  function cacheAssets(section) {\n    var batch = assets[section];\n\n    return caches.open(CACHE_NAME).then(function (cache) {\n      return addAllNormalized(cache, batch, {\n        bust: params.version,\n        request: params.prefetchRequest\n      });\n    }).then(function () {\n      logGroup('Cached assets: ' + section, batch);\n    })['catch'](function (e) {\n      console.error(e);\n      throw e;\n    });\n  }\n\n  function cacheChanged(section) {\n    return getLastCache().then(function (args) {\n      if (!args) {\n        return cacheAssets(section);\n      }\n\n      var lastCache = args[0];\n      var lastKeys = args[1];\n      var lastData = args[2];\n\n      var lastMap = lastData.hashmap;\n      var lastVersion = lastData.version;\n\n      if (!lastData.hashmap || lastVersion === params.version) {\n        return cacheAssets(section);\n      }\n\n      var lastHashedAssets = Object.keys(lastMap).map(function (hash) {\n        return lastMap[hash];\n      });\n\n      var lastUrls = lastKeys.map(function (req) {\n        var url = new URL(req.url);\n        url.search = '';\n\n        return url.toString();\n      });\n\n      var sectionAssets = assets[section];\n      var moved = [];\n      var changed = sectionAssets.filter(function (url) {\n        if (lastUrls.indexOf(url) === -1 || lastHashedAssets.indexOf(url) === -1) {\n          return true;\n        }\n\n        return false;\n      });\n\n      Object.keys(hashesMap).forEach(function (hash) {\n        var asset = hashesMap[hash];\n\n        // Return if not in sectionAssets or in changed or moved array\n        if (sectionAssets.indexOf(asset) === -1 || changed.indexOf(asset) !== -1 || moved.indexOf(asset) !== -1) return;\n\n        var lastAsset = lastMap[hash];\n\n        if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {\n          moved.push([lastAsset, asset]);\n        } else {\n          changed.push(asset);\n        }\n      });\n\n      logGroup('Changed assets: ' + section, changed);\n      logGroup('Moved assets: ' + section, moved);\n\n      var movedResponses = Promise.all(moved.map(function (pair) {\n        return lastCache.match(pair[0]).then(function (response) {\n          return [pair[1], response];\n        });\n      }));\n\n      return caches.open(CACHE_NAME).then(function (cache) {\n        var move = movedResponses.then(function (responses) {\n          return Promise.all(responses.map(function (pair) {\n            return cache.put(pair[0], pair[1]);\n          }));\n        });\n\n        return Promise.all([move, addAllNormalized(cache, changed, {\n          bust: params.version,\n          request: params.prefetchRequest\n        })]);\n      });\n    });\n  }\n\n  function deleteObsolete() {\n    return caches.keys().then(function (keys) {\n      var all = keys.map(function (key) {\n        if (key.indexOf(CACHE_PREFIX) !== 0 || key.indexOf(CACHE_NAME) === 0) return;\n\n        console.log('[SW]:', 'Delete cache:', key);\n        return caches['delete'](key);\n      });\n\n      return Promise.all(all);\n    });\n  }\n\n  function getLastCache() {\n    return caches.keys().then(function (keys) {\n      var index = keys.length;\n      var key = undefined;\n\n      while (index--) {\n        key = keys[index];\n\n        if (key.indexOf(CACHE_PREFIX) === 0) {\n          break;\n        }\n      }\n\n      if (!key) return;\n\n      var cache = undefined;\n\n      return caches.open(key).then(function (_cache) {\n        cache = _cache;\n        return _cache.match(new URL(STORED_DATA_KEY, location).toString());\n      }).then(function (response) {\n        if (!response) return;\n\n        return Promise.all([cache, cache.keys(), response.json()]);\n      });\n    });\n  }\n\n  function storeCacheData() {\n    return caches.open(CACHE_NAME).then(function (cache) {\n      var data = new Response(JSON.stringify({\n        version: params.version,\n        hashmap: hashesMap\n      }));\n\n      return cache.put(new URL(STORED_DATA_KEY, location).toString(), data);\n    });\n  }\n\n  self.addEventListener('fetch', function (event) {\n    var requestUrl = event.request.url;\n    var url = new URL(requestUrl);\n    var urlString = undefined;\n\n    if (externals.indexOf(requestUrl) !== -1) {\n      urlString = requestUrl;\n    } else {\n      url.search = '';\n      urlString = url.toString();\n    }\n\n    // Handle only GET requests\n    var isGET = event.request.method === 'GET';\n    var assetMatches = allAssets.indexOf(urlString) !== -1;\n    var cacheUrl = urlString;\n\n    if (!assetMatches) {\n      var cacheRewrite = matchCacheMap(event.request);\n\n      if (cacheRewrite) {\n        cacheUrl = cacheRewrite;\n        assetMatches = true;\n      }\n    }\n\n    if (!assetMatches && isGET) {\n      // If isn't a cached asset and is a navigation request,\n      // fallback to navigateFallbackURL if available\n      if (navigateFallbackURL && isNavigateRequest(event.request)) {\n        event.respondWith(handleNavigateFallback(fetch(event.request)));\n\n        return;\n      }\n    }\n\n    if (!assetMatches || !isGET) {\n      // Fix for https://twitter.com/wanderview/status/696819243262873600\n      if (url.origin !== location.origin && navigator.userAgent.indexOf('Firefox/44.') !== -1) {\n        event.respondWith(fetch(event.request));\n      }\n\n      return;\n    }\n\n    // Logic of caching / fetching is here\n    // * urlString -- url to match from the CACHE_NAME\n    // * event.request -- original Request to perform fetch() if necessary\n    var resource = undefined;\n\n    if (responseStrategy === 'network-first') {\n      resource = networkFirstResponse(event, urlString, cacheUrl);\n    }\n    // 'cache-first'\n    // (responseStrategy has been validated before)\n    else {\n        resource = cacheFirstResponse(event, urlString, cacheUrl);\n      }\n\n    if (navigateFallbackURL && isNavigateRequest(event.request)) {\n      resource = handleNavigateFallback(resource);\n    }\n\n    event.respondWith(resource);\n  });\n\n  self.addEventListener('message', function (e) {\n    var data = e.data;\n    if (!data) return;\n\n    switch (data.action) {\n      case 'skipWaiting':\n        {\n          if (self.skipWaiting) self.skipWaiting();\n        }break;\n    }\n  });\n\n  function cacheFirstResponse(event, urlString, cacheUrl) {\n    return cachesMatch(cacheUrl, CACHE_NAME).then(function (response) {\n      if (response) {\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + cacheUrl + '](' + urlString + ') from cache');\n        }\n\n        return response;\n      }\n\n      // Load and cache known assets\n      var fetching = fetch(event.request).then(function (response) {\n        if (!response.ok) {\n          if (DEBUG) {\n            console.log('[SW]:', 'URL [' + urlString + '] wrong response: [' + response.status + '] ' + response.type);\n          }\n\n          return response;\n        }\n\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + urlString + '] from network');\n        }\n\n        if (cacheUrl === urlString) {\n          (function () {\n            var responseClone = response.clone();\n            var storing = caches.open(CACHE_NAME).then(function (cache) {\n              return cache.put(urlString, responseClone);\n            }).then(function () {\n              console.log('[SW]:', 'Cache asset: ' + urlString);\n            });\n\n            event.waitUntil(storing);\n          })();\n        }\n\n        return response;\n      });\n\n      return fetching;\n    });\n  }\n\n  function networkFirstResponse(event, urlString, cacheUrl) {\n    return fetch(event.request).then(function (response) {\n      if (response.ok) {\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + urlString + '] from network');\n        }\n\n        return response;\n      }\n\n      // Throw to reach the code in the catch below\n      throw new Error('Response is not ok');\n    })\n    // This needs to be in a catch() and not just in the then() above\n    // cause if your network is down, the fetch() will throw\n    ['catch'](function () {\n      if (DEBUG) {\n        console.log('[SW]:', 'URL [' + urlString + '] from cache if possible');\n      }\n\n      return cachesMatch(cacheUrl, CACHE_NAME);\n    });\n  }\n\n  function handleNavigateFallback(fetching) {\n    return fetching['catch'](function () {}).then(function (response) {\n      var isOk = response && response.ok;\n      var isRedirect = response && response.type === 'opaqueredirect';\n\n      if (isOk || isRedirect && !navigateFallbackForRedirects) {\n        return response;\n      }\n\n      if (DEBUG) {\n        console.log('[SW]:', 'Loading navigation fallback [' + navigateFallbackURL + '] from cache');\n      }\n\n      return cachesMatch(navigateFallbackURL, CACHE_NAME);\n    });\n  }\n\n  function mapAssets() {\n    Object.keys(assets).forEach(function (key) {\n      assets[key] = assets[key].map(function (path) {\n        var url = new URL(path, location);\n\n        if (externals.indexOf(path) === -1) {\n          url.search = '';\n        } else {\n          // Remove hash from possible passed externals\n          url.hash = '';\n        }\n\n        return url.toString();\n      });\n    });\n\n    Object.keys(loadersMap).forEach(function (key) {\n      loadersMap[key] = loadersMap[key].map(function (path) {\n        var url = new URL(path, location);\n\n        if (externals.indexOf(path) === -1) {\n          url.search = '';\n        } else {\n          // Remove hash from possible passed externals\n          url.hash = '';\n        }\n\n        return url.toString();\n      });\n    });\n\n    hashesMap = Object.keys(hashesMap).reduce(function (result, hash) {\n      var url = new URL(hashesMap[hash], location);\n      url.search = '';\n\n      result[hash] = url.toString();\n      return result;\n    }, {});\n\n    externals = externals.map(function (path) {\n      var url = new URL(path, location);\n      url.hash = '';\n\n      return url.toString();\n    });\n  }\n\n  function addAllNormalized(cache, requests, options) {\n    var allowLoaders = options.allowLoaders !== false;\n    var bustValue = options && options.bust;\n    var requestInit = options.request || {\n      credentials: 'omit',\n      mode: 'cors'\n    };\n\n    return Promise.all(requests.map(function (request) {\n      if (bustValue) {\n        request = applyCacheBust(request, bustValue);\n      }\n\n      return fetch(request, requestInit).then(fixRedirectedResponse);\n    })).then(function (responses) {\n      if (responses.some(function (response) {\n        return !response.ok;\n      })) {\n        return Promise.reject(new Error('Wrong response status'));\n      }\n\n      var extracted = [];\n      var addAll = responses.map(function (response, i) {\n        if (allowLoaders) {\n          extracted.push(extractAssetsWithLoaders(requests[i], response));\n        }\n\n        return cache.put(requests[i], response);\n      });\n\n      if (extracted.length) {\n        (function () {\n          var newOptions = copyObject(options);\n          newOptions.allowLoaders = false;\n\n          var waitAll = addAll;\n\n          addAll = Promise.all(extracted).then(function (all) {\n            var extractedRequests = [].concat.apply([], all);\n\n            if (requests.length) {\n              waitAll = waitAll.concat(addAllNormalized(cache, extractedRequests, newOptions));\n            }\n\n            return Promise.all(waitAll);\n          });\n        })();\n      } else {\n        addAll = Promise.all(addAll);\n      }\n\n      return addAll;\n    });\n  }\n\n  function extractAssetsWithLoaders(request, response) {\n    var all = Object.keys(loadersMap).map(function (key) {\n      var loader = loadersMap[key];\n\n      if (loader.indexOf(request) !== -1 && loaders[key]) {\n        return loaders[key](response.clone());\n      }\n    }).filter(function (a) {\n      return !!a;\n    });\n\n    return Promise.all(all).then(function (all) {\n      return [].concat.apply([], all);\n    });\n  }\n\n  function matchCacheMap(request) {\n    var urlString = request.url;\n    var url = new URL(urlString);\n\n    var requestType = undefined;\n\n    if (request.mode === 'navigate') {\n      requestType = 'navigate';\n    } else if (url.origin === location.origin) {\n      requestType = 'same-origin';\n    } else {\n      requestType = 'cross-origin';\n    }\n\n    for (var i = 0; i < cacheMaps.length; i++) {\n      var map = cacheMaps[i];\n\n      if (!map) continue;\n      if (map.requestTypes && map.requestTypes.indexOf(requestType) === -1) {\n        continue;\n      }\n\n      var newString = undefined;\n\n      if (typeof map.match === 'function') {\n        newString = map.match(url, request);\n      } else {\n        newString = urlString.replace(map.match, map.to);\n      }\n\n      if (newString && newString !== urlString) {\n        return newString;\n      }\n    }\n  }\n}\n\nfunction cachesMatch(request, cacheName) {\n  return caches.match(request, {\n    cacheName: cacheName\n  }).then(function (response) {\n    if (isNotRedirectedResponse()) {\n      return response;\n    }\n\n    // Fix already cached redirected responses\n    return fixRedirectedResponse(response).then(function (fixedResponse) {\n      return caches.open(cacheName).then(function (cache) {\n        return cache.put(request, fixedResponse);\n      }).then(function () {\n        return fixedResponse;\n      });\n    });\n  })\n  // Return void if error happened (cache not found)\n  ['catch'](function () {});\n}\n\nfunction applyCacheBust(asset, key) {\n  var hasQuery = asset.indexOf('?') !== -1;\n  return asset + (hasQuery ? '&' : '?') + '__uncache=' + encodeURIComponent(key);\n}\n\nfunction getClientsURLs() {\n  if (!self.clients) {\n    return Promise.resolve([]);\n  }\n\n  return self.clients.matchAll({\n    includeUncontrolled: true\n  }).then(function (clients) {\n    if (!clients.length) return [];\n\n    var result = [];\n\n    clients.forEach(function (client) {\n      var url = new URL(client.url);\n      url.search = '';\n      url.hash = '';\n      var urlString = url.toString();\n\n      if (!result.length || result.indexOf(urlString) === -1) {\n        result.push(urlString);\n      }\n    });\n\n    return result;\n  });\n}\n\nfunction isNavigateRequest(request) {\n  return request.mode === 'navigate' || request.headers.get('Upgrade-Insecure-Requests') || (request.headers.get('Accept') || '').indexOf('text/html') !== -1;\n}\n\nfunction isNotRedirectedResponse(response) {\n  return !response || !response.redirected || !response.ok || response.type === 'opaqueredirect';\n}\n\n// Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85\nfunction fixRedirectedResponse(response) {\n  if (isNotRedirectedResponse(response)) {\n    return Promise.resolve(response);\n  }\n\n  var body = 'body' in response ? Promise.resolve(response.body) : response.blob();\n\n  return body.then(function (data) {\n    return new Response(data, {\n      headers: response.headers,\n      status: response.status\n    });\n  });\n}\n\nfunction copyObject(original) {\n  return Object.keys(original).reduce(function (result, key) {\n    result[key] = original[key];\n    return result;\n  }, {});\n}\n\nfunction logGroup(title, assets) {\n  console.groupCollapsed('[SW]:', title);\n\n  assets.forEach(function (asset) {\n    console.log('Asset:', asset);\n  });\n\n  console.groupEnd();\n}\n        WebpackServiceWorker(__wpo, {\nloaders: {},\ncacheMaps: [],\n});\n        module.exports = __webpack_require__(0)\n      \n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L29mZmxpbmUtcGx1Z2luL3RwbHMvZW1wdHktZW50cnkuanM/ZmQ1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxJQUFJOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciB3YWl0VW50aWwgPSBFeHRlbmRhYmxlRXZlbnQucHJvdG90eXBlLndhaXRVbnRpbDtcbiAgdmFyIHJlc3BvbmRXaXRoID0gRmV0Y2hFdmVudC5wcm90b3R5cGUucmVzcG9uZFdpdGg7XG4gIHZhciBwcm9taXNlc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgRXh0ZW5kYWJsZUV2ZW50LnByb3RvdHlwZS53YWl0VW50aWwgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBleHRlbmRhYmxlRXZlbnQgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlcyA9IHByb21pc2VzTWFwLmdldChleHRlbmRhYmxlRXZlbnQpO1xuXG4gICAgaWYgKHByb21pc2VzKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZShwcm9taXNlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJvbWlzZXMgPSBbUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpXTtcbiAgICBwcm9taXNlc01hcC5zZXQoZXh0ZW5kYWJsZUV2ZW50LCBwcm9taXNlcyk7XG5cbiAgICAvLyBjYWxsIG9yaWdpbmFsIG1ldGhvZFxuICAgIHJldHVybiB3YWl0VW50aWwuY2FsbChleHRlbmRhYmxlRXZlbnQsIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gcHJvY2Vzc1Byb21pc2VzKCkge1xuICAgICAgdmFyIGxlbiA9IHByb21pc2VzLmxlbmd0aDtcblxuICAgICAgLy8gd2FpdCBmb3IgYWxsIHRvIHNldHRsZVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcFtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaGF2ZSBuZXcgaXRlbXMgYmVlbiBhZGRlZD8gSWYgc28sIHdhaXQgYWdhaW5cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCAhPSBsZW4pIHJldHVybiBwcm9jZXNzUHJvbWlzZXMoKTtcbiAgICAgICAgLy8gd2UncmUgZG9uZSFcbiAgICAgICAgcHJvbWlzZXNNYXBbXCJkZWxldGVcIl0oZXh0ZW5kYWJsZUV2ZW50KTtcbiAgICAgICAgLy8gcmVqZWN0IGlmIG9uZSBvZiB0aGUgcHJvbWlzZXMgcmVqZWN0ZWRcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfTtcblxuICBGZXRjaEV2ZW50LnByb3RvdHlwZS5yZXNwb25kV2l0aCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdGhpcy53YWl0VW50aWwocHJvbWlzZSk7XG4gICAgcmV0dXJuIHJlc3BvbmRXaXRoLmNhbGwodGhpcywgcHJvbWlzZSk7XG4gIH07XG59KSgpOztcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIERFQlVHID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgREVCVUcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV2VicGFja1NlcnZpY2VXb3JrZXIocGFyYW1zLCBoZWxwZXJzKSB7XG4gIHZhciBsb2FkZXJzID0gaGVscGVycy5sb2FkZXJzO1xuICB2YXIgY2FjaGVNYXBzID0gaGVscGVycy5jYWNoZU1hcHM7XG5cbiAgdmFyIHN0cmF0ZWd5ID0gcGFyYW1zLnN0cmF0ZWd5O1xuICB2YXIgcmVzcG9uc2VTdHJhdGVneSA9IHBhcmFtcy5yZXNwb25zZVN0cmF0ZWd5O1xuXG4gIHZhciBhc3NldHMgPSBwYXJhbXMuYXNzZXRzO1xuICB2YXIgbG9hZGVyc01hcCA9IHBhcmFtcy5sb2FkZXJzIHx8IHt9O1xuXG4gIHZhciBoYXNoZXNNYXAgPSBwYXJhbXMuaGFzaGVzTWFwO1xuICB2YXIgZXh0ZXJuYWxzID0gcGFyYW1zLmV4dGVybmFscztcblxuICAvLyBOb3QgdXNlZCB5ZXRcbiAgLy8gY29uc3QgYWx3YXlzUmV2YWxpZGF0ZSA9IHBhcmFtcy5hbHdheXNSZXZhbGlkYXRlO1xuICAvLyBjb25zdCBpZ25vcmVTZWFyY2ggPSBwYXJhbXMuaWdub3JlU2VhcmNoO1xuICAvLyBjb25zdCBwcmVmZXJPbmxpbmUgPSBwYXJhbXMucHJlZmVyT25saW5lO1xuXG4gIHZhciBDQUNIRV9QUkVGSVggPSBwYXJhbXMubmFtZTtcbiAgdmFyIENBQ0hFX1RBRyA9IHBhcmFtcy52ZXJzaW9uO1xuICB2YXIgQ0FDSEVfTkFNRSA9IENBQ0hFX1BSRUZJWCArICc6JyArIENBQ0hFX1RBRztcblxuICB2YXIgU1RPUkVEX0RBVEFfS0VZID0gJ19fb2ZmbGluZV93ZWJwYWNrX19kYXRhJztcblxuICBtYXBBc3NldHMoKTtcblxuICB2YXIgYWxsQXNzZXRzID0gW10uY29uY2F0KGFzc2V0cy5tYWluLCBhc3NldHMuYWRkaXRpb25hbCwgYXNzZXRzLm9wdGlvbmFsKTtcbiAgdmFyIG5hdmlnYXRlRmFsbGJhY2tVUkwgPSBwYXJhbXMubmF2aWdhdGVGYWxsYmFja1VSTDtcbiAgdmFyIG5hdmlnYXRlRmFsbGJhY2tGb3JSZWRpcmVjdHMgPSBwYXJhbXMubmF2aWdhdGVGYWxsYmFja0ZvclJlZGlyZWN0cztcblxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbGwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnSW5zdGFsbCBldmVudCcpO1xuXG4gICAgdmFyIGluc3RhbGxpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc3RyYXRlZ3kgPT09ICdjaGFuZ2VkJykge1xuICAgICAgaW5zdGFsbGluZyA9IGNhY2hlQ2hhbmdlZCgnbWFpbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YWxsaW5nID0gY2FjaGVBc3NldHMoJ21haW4nKTtcbiAgICB9XG5cbiAgICBldmVudC53YWl0VW50aWwoaW5zdGFsbGluZyk7XG4gIH0pO1xuXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZhdGUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnQWN0aXZhdGUgZXZlbnQnKTtcblxuICAgIHZhciBhY3RpdmF0aW9uID0gY2FjaGVBZGRpdGlvbmFsKCk7XG5cbiAgICAvLyBEZWxldGUgYWxsIGFzc2V0cyB3aGljaCBuYW1lIHN0YXJ0cyB3aXRoIENBQ0hFX1BSRUZJWCBhbmRcbiAgICAvLyBpcyBub3QgY3VycmVudCBjYWNoZSAoQ0FDSEVfTkFNRSlcbiAgICBhY3RpdmF0aW9uID0gYWN0aXZhdGlvbi50aGVuKHN0b3JlQ2FjaGVEYXRhKTtcbiAgICBhY3RpdmF0aW9uID0gYWN0aXZhdGlvbi50aGVuKGRlbGV0ZU9ic29sZXRlKTtcbiAgICBhY3RpdmF0aW9uID0gYWN0aXZhdGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmNsaWVudHMgJiYgc2VsZi5jbGllbnRzLmNsYWltKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsaWVudHMuY2xhaW0oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGV2ZW50LndhaXRVbnRpbChhY3RpdmF0aW9uKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2FjaGVBZGRpdGlvbmFsKCkge1xuICAgIGlmICghYXNzZXRzLmFkZGl0aW9uYWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnQ2FjaGluZyBhZGRpdGlvbmFsJyk7XG4gICAgfVxuXG4gICAgdmFyIG9wZXJhdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChzdHJhdGVneSA9PT0gJ2NoYW5nZWQnKSB7XG4gICAgICBvcGVyYXRpb24gPSBjYWNoZUNoYW5nZWQoJ2FkZGl0aW9uYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gY2FjaGVBc3NldHMoJ2FkZGl0aW9uYWwnKTtcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgZmFpbCBvZiBgYWRkaXRpb25hbGAgY2FjaGUgc2VjdGlvblxuICAgIHJldHVybiBvcGVyYXRpb25bJ2NhdGNoJ10oZnVuY3Rpb24gKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTV106JywgJ0NhY2hlIHNlY3Rpb24gYGFkZGl0aW9uYWxgIGZhaWxlZCB0byBsb2FkJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZUFzc2V0cyhzZWN0aW9uKSB7XG4gICAgdmFyIGJhdGNoID0gYXNzZXRzW3NlY3Rpb25dO1xuXG4gICAgcmV0dXJuIGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICByZXR1cm4gYWRkQWxsTm9ybWFsaXplZChjYWNoZSwgYmF0Y2gsIHtcbiAgICAgICAgYnVzdDogcGFyYW1zLnZlcnNpb24sXG4gICAgICAgIHJlcXVlc3Q6IHBhcmFtcy5wcmVmZXRjaFJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgbG9nR3JvdXAoJ0NhY2hlZCBhc3NldHM6ICcgKyBzZWN0aW9uLCBiYXRjaCk7XG4gICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVDaGFuZ2VkKHNlY3Rpb24pIHtcbiAgICByZXR1cm4gZ2V0TGFzdENhY2hlKCkudGhlbihmdW5jdGlvbiAoYXJncykge1xuICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgIHJldHVybiBjYWNoZUFzc2V0cyhzZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3RDYWNoZSA9IGFyZ3NbMF07XG4gICAgICB2YXIgbGFzdEtleXMgPSBhcmdzWzFdO1xuICAgICAgdmFyIGxhc3REYXRhID0gYXJnc1syXTtcblxuICAgICAgdmFyIGxhc3RNYXAgPSBsYXN0RGF0YS5oYXNobWFwO1xuICAgICAgdmFyIGxhc3RWZXJzaW9uID0gbGFzdERhdGEudmVyc2lvbjtcblxuICAgICAgaWYgKCFsYXN0RGF0YS5oYXNobWFwIHx8IGxhc3RWZXJzaW9uID09PSBwYXJhbXMudmVyc2lvbikge1xuICAgICAgICByZXR1cm4gY2FjaGVBc3NldHMoc2VjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0SGFzaGVkQXNzZXRzID0gT2JqZWN0LmtleXMobGFzdE1hcCkubWFwKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgIHJldHVybiBsYXN0TWFwW2hhc2hdO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBsYXN0VXJscyA9IGxhc3RLZXlzLm1hcChmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgICAgICB1cmwuc2VhcmNoID0gJyc7XG5cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzZWN0aW9uQXNzZXRzID0gYXNzZXRzW3NlY3Rpb25dO1xuICAgICAgdmFyIG1vdmVkID0gW107XG4gICAgICB2YXIgY2hhbmdlZCA9IHNlY3Rpb25Bc3NldHMuZmlsdGVyKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgaWYgKGxhc3RVcmxzLmluZGV4T2YodXJsKSA9PT0gLTEgfHwgbGFzdEhhc2hlZEFzc2V0cy5pbmRleE9mKHVybCkgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmtleXMoaGFzaGVzTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgIHZhciBhc3NldCA9IGhhc2hlc01hcFtoYXNoXTtcblxuICAgICAgICAvLyBSZXR1cm4gaWYgbm90IGluIHNlY3Rpb25Bc3NldHMgb3IgaW4gY2hhbmdlZCBvciBtb3ZlZCBhcnJheVxuICAgICAgICBpZiAoc2VjdGlvbkFzc2V0cy5pbmRleE9mKGFzc2V0KSA9PT0gLTEgfHwgY2hhbmdlZC5pbmRleE9mKGFzc2V0KSAhPT0gLTEgfHwgbW92ZWQuaW5kZXhPZihhc3NldCkgIT09IC0xKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGxhc3RBc3NldCA9IGxhc3RNYXBbaGFzaF07XG5cbiAgICAgICAgaWYgKGxhc3RBc3NldCAmJiBsYXN0VXJscy5pbmRleE9mKGxhc3RBc3NldCkgIT09IC0xKSB7XG4gICAgICAgICAgbW92ZWQucHVzaChbbGFzdEFzc2V0LCBhc3NldF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYW5nZWQucHVzaChhc3NldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBsb2dHcm91cCgnQ2hhbmdlZCBhc3NldHM6ICcgKyBzZWN0aW9uLCBjaGFuZ2VkKTtcbiAgICAgIGxvZ0dyb3VwKCdNb3ZlZCBhc3NldHM6ICcgKyBzZWN0aW9uLCBtb3ZlZCk7XG5cbiAgICAgIHZhciBtb3ZlZFJlc3BvbnNlcyA9IFByb21pc2UuYWxsKG1vdmVkLm1hcChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICByZXR1cm4gbGFzdENhY2hlLm1hdGNoKHBhaXJbMF0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgcmV0dXJuIFtwYWlyWzFdLCByZXNwb25zZV07XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSkudGhlbihmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgdmFyIG1vdmUgPSBtb3ZlZFJlc3BvbnNlcy50aGVuKGZ1bmN0aW9uIChyZXNwb25zZXMpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzcG9uc2VzLm1hcChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLnB1dChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbW92ZSwgYWRkQWxsTm9ybWFsaXplZChjYWNoZSwgY2hhbmdlZCwge1xuICAgICAgICAgIGJ1c3Q6IHBhcmFtcy52ZXJzaW9uLFxuICAgICAgICAgIHJlcXVlc3Q6IHBhcmFtcy5wcmVmZXRjaFJlcXVlc3RcbiAgICAgICAgfSldKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlT2Jzb2xldGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlcy5rZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgdmFyIGFsbCA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKENBQ0hFX1BSRUZJWCkgIT09IDAgfHwga2V5LmluZGV4T2YoQ0FDSEVfTkFNRSkgPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnRGVsZXRlIGNhY2hlOicsIGtleSk7XG4gICAgICAgIHJldHVybiBjYWNoZXNbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFsbCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMYXN0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlcy5rZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgdmFyIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcblxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoQ0FDSEVfUFJFRklYKSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5KSByZXR1cm47XG5cbiAgICAgIHZhciBjYWNoZSA9IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGNhY2hlcy5vcGVuKGtleSkudGhlbihmdW5jdGlvbiAoX2NhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gX2NhY2hlO1xuICAgICAgICByZXR1cm4gX2NhY2hlLm1hdGNoKG5ldyBVUkwoU1RPUkVEX0RBVEFfS0VZLCBsb2NhdGlvbikudG9TdHJpbmcoKSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtjYWNoZSwgY2FjaGUua2V5cygpLCByZXNwb25zZS5qc29uKCldKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcmVDYWNoZURhdGEoKSB7XG4gICAgcmV0dXJuIGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZlcnNpb246IHBhcmFtcy52ZXJzaW9uLFxuICAgICAgICBoYXNobWFwOiBoYXNoZXNNYXBcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGNhY2hlLnB1dChuZXcgVVJMKFNUT1JFRF9EQVRBX0tFWSwgbG9jYXRpb24pLnRvU3RyaW5nKCksIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdmZXRjaCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciByZXF1ZXN0VXJsID0gZXZlbnQucmVxdWVzdC51cmw7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwocmVxdWVzdFVybCk7XG4gICAgdmFyIHVybFN0cmluZyA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChleHRlcm5hbHMuaW5kZXhPZihyZXF1ZXN0VXJsKSAhPT0gLTEpIHtcbiAgICAgIHVybFN0cmluZyA9IHJlcXVlc3RVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybC5zZWFyY2ggPSAnJztcbiAgICAgIHVybFN0cmluZyA9IHVybC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvbmx5IEdFVCByZXF1ZXN0c1xuICAgIHZhciBpc0dFVCA9IGV2ZW50LnJlcXVlc3QubWV0aG9kID09PSAnR0VUJztcbiAgICB2YXIgYXNzZXRNYXRjaGVzID0gYWxsQXNzZXRzLmluZGV4T2YodXJsU3RyaW5nKSAhPT0gLTE7XG4gICAgdmFyIGNhY2hlVXJsID0gdXJsU3RyaW5nO1xuXG4gICAgaWYgKCFhc3NldE1hdGNoZXMpIHtcbiAgICAgIHZhciBjYWNoZVJld3JpdGUgPSBtYXRjaENhY2hlTWFwKGV2ZW50LnJlcXVlc3QpO1xuXG4gICAgICBpZiAoY2FjaGVSZXdyaXRlKSB7XG4gICAgICAgIGNhY2hlVXJsID0gY2FjaGVSZXdyaXRlO1xuICAgICAgICBhc3NldE1hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXNzZXRNYXRjaGVzICYmIGlzR0VUKSB7XG4gICAgICAvLyBJZiBpc24ndCBhIGNhY2hlZCBhc3NldCBhbmQgaXMgYSBuYXZpZ2F0aW9uIHJlcXVlc3QsXG4gICAgICAvLyBmYWxsYmFjayB0byBuYXZpZ2F0ZUZhbGxiYWNrVVJMIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKG5hdmlnYXRlRmFsbGJhY2tVUkwgJiYgaXNOYXZpZ2F0ZVJlcXVlc3QoZXZlbnQucmVxdWVzdCkpIHtcbiAgICAgICAgZXZlbnQucmVzcG9uZFdpdGgoaGFuZGxlTmF2aWdhdGVGYWxsYmFjayhmZXRjaChldmVudC5yZXF1ZXN0KSkpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFzc2V0TWF0Y2hlcyB8fCAhaXNHRVQpIHtcbiAgICAgIC8vIEZpeCBmb3IgaHR0cHM6Ly90d2l0dGVyLmNvbS93YW5kZXJ2aWV3L3N0YXR1cy82OTY4MTkyNDMyNjI4NzM2MDBcbiAgICAgIGlmICh1cmwub3JpZ2luICE9PSBsb2NhdGlvbi5vcmlnaW4gJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94LzQ0LicpICE9PSAtMSkge1xuICAgICAgICBldmVudC5yZXNwb25kV2l0aChmZXRjaChldmVudC5yZXF1ZXN0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBMb2dpYyBvZiBjYWNoaW5nIC8gZmV0Y2hpbmcgaXMgaGVyZVxuICAgIC8vICogdXJsU3RyaW5nIC0tIHVybCB0byBtYXRjaCBmcm9tIHRoZSBDQUNIRV9OQU1FXG4gICAgLy8gKiBldmVudC5yZXF1ZXN0IC0tIG9yaWdpbmFsIFJlcXVlc3QgdG8gcGVyZm9ybSBmZXRjaCgpIGlmIG5lY2Vzc2FyeVxuICAgIHZhciByZXNvdXJjZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChyZXNwb25zZVN0cmF0ZWd5ID09PSAnbmV0d29yay1maXJzdCcpIHtcbiAgICAgIHJlc291cmNlID0gbmV0d29ya0ZpcnN0UmVzcG9uc2UoZXZlbnQsIHVybFN0cmluZywgY2FjaGVVcmwpO1xuICAgIH1cbiAgICAvLyAnY2FjaGUtZmlyc3QnXG4gICAgLy8gKHJlc3BvbnNlU3RyYXRlZ3kgaGFzIGJlZW4gdmFsaWRhdGVkIGJlZm9yZSlcbiAgICBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2UgPSBjYWNoZUZpcnN0UmVzcG9uc2UoZXZlbnQsIHVybFN0cmluZywgY2FjaGVVcmwpO1xuICAgICAgfVxuXG4gICAgaWYgKG5hdmlnYXRlRmFsbGJhY2tVUkwgJiYgaXNOYXZpZ2F0ZVJlcXVlc3QoZXZlbnQucmVxdWVzdCkpIHtcbiAgICAgIHJlc291cmNlID0gaGFuZGxlTmF2aWdhdGVGYWxsYmFjayhyZXNvdXJjZSk7XG4gICAgfVxuXG4gICAgZXZlbnQucmVzcG9uZFdpdGgocmVzb3VyY2UpO1xuICB9KTtcblxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgIGlmICghZGF0YSkgcmV0dXJuO1xuXG4gICAgc3dpdGNoIChkYXRhLmFjdGlvbikge1xuICAgICAgY2FzZSAnc2tpcFdhaXRpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHNlbGYuc2tpcFdhaXRpbmcpIHNlbGYuc2tpcFdhaXRpbmcoKTtcbiAgICAgICAgfWJyZWFrO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2FjaGVGaXJzdFJlc3BvbnNlKGV2ZW50LCB1cmxTdHJpbmcsIGNhY2hlVXJsKSB7XG4gICAgcmV0dXJuIGNhY2hlc01hdGNoKGNhY2hlVXJsLCBDQUNIRV9OQU1FKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU1ddOicsICdVUkwgWycgKyBjYWNoZVVybCArICddKCcgKyB1cmxTdHJpbmcgKyAnKSBmcm9tIGNhY2hlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgYW5kIGNhY2hlIGtub3duIGFzc2V0c1xuICAgICAgdmFyIGZldGNoaW5nID0gZmV0Y2goZXZlbnQucmVxdWVzdCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTV106JywgJ1VSTCBbJyArIHVybFN0cmluZyArICddIHdyb25nIHJlc3BvbnNlOiBbJyArIHJlc3BvbnNlLnN0YXR1cyArICddICcgKyByZXNwb25zZS50eXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnVVJMIFsnICsgdXJsU3RyaW5nICsgJ10gZnJvbSBuZXR3b3JrJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FjaGVVcmwgPT09IHVybFN0cmluZykge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgc3RvcmluZyA9IGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZS5wdXQodXJsU3RyaW5nLCByZXNwb25zZUNsb25lKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnQ2FjaGUgYXNzZXQ6ICcgKyB1cmxTdHJpbmcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbChzdG9yaW5nKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBmZXRjaGluZztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ldHdvcmtGaXJzdFJlc3BvbnNlKGV2ZW50LCB1cmxTdHJpbmcsIGNhY2hlVXJsKSB7XG4gICAgcmV0dXJuIGZldGNoKGV2ZW50LnJlcXVlc3QpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tTV106JywgJ1VSTCBbJyArIHVybFN0cmluZyArICddIGZyb20gbmV0d29yaycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyB0byByZWFjaCB0aGUgY29kZSBpbiB0aGUgY2F0Y2ggYmVsb3dcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IG9rJyk7XG4gICAgfSlcbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGluIGEgY2F0Y2goKSBhbmQgbm90IGp1c3QgaW4gdGhlIHRoZW4oKSBhYm92ZVxuICAgIC8vIGNhdXNlIGlmIHlvdXIgbmV0d29yayBpcyBkb3duLCB0aGUgZmV0Y2goKSB3aWxsIHRocm93XG4gICAgWydjYXRjaCddKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnVVJMIFsnICsgdXJsU3RyaW5nICsgJ10gZnJvbSBjYWNoZSBpZiBwb3NzaWJsZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVzTWF0Y2goY2FjaGVVcmwsIENBQ0hFX05BTUUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmF2aWdhdGVGYWxsYmFjayhmZXRjaGluZykge1xuICAgIHJldHVybiBmZXRjaGluZ1snY2F0Y2gnXShmdW5jdGlvbiAoKSB7fSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHZhciBpc09rID0gcmVzcG9uc2UgJiYgcmVzcG9uc2Uub2s7XG4gICAgICB2YXIgaXNSZWRpcmVjdCA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWVyZWRpcmVjdCc7XG5cbiAgICAgIGlmIChpc09rIHx8IGlzUmVkaXJlY3QgJiYgIW5hdmlnYXRlRmFsbGJhY2tGb3JSZWRpcmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTV106JywgJ0xvYWRpbmcgbmF2aWdhdGlvbiBmYWxsYmFjayBbJyArIG5hdmlnYXRlRmFsbGJhY2tVUkwgKyAnXSBmcm9tIGNhY2hlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZXNNYXRjaChuYXZpZ2F0ZUZhbGxiYWNrVVJMLCBDQUNIRV9OQU1FKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcEFzc2V0cygpIHtcbiAgICBPYmplY3Qua2V5cyhhc3NldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYXNzZXRzW2tleV0gPSBhc3NldHNba2V5XS5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHVybCA9IG5ldyBVUkwocGF0aCwgbG9jYXRpb24pO1xuXG4gICAgICAgIGlmIChleHRlcm5hbHMuaW5kZXhPZihwYXRoKSA9PT0gLTEpIHtcbiAgICAgICAgICB1cmwuc2VhcmNoID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGhhc2ggZnJvbSBwb3NzaWJsZSBwYXNzZWQgZXh0ZXJuYWxzXG4gICAgICAgICAgdXJsLmhhc2ggPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmtleXMobG9hZGVyc01hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBsb2FkZXJzTWFwW2tleV0gPSBsb2FkZXJzTWFwW2tleV0ubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciB1cmwgPSBuZXcgVVJMKHBhdGgsIGxvY2F0aW9uKTtcblxuICAgICAgICBpZiAoZXh0ZXJuYWxzLmluZGV4T2YocGF0aCkgPT09IC0xKSB7XG4gICAgICAgICAgdXJsLnNlYXJjaCA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSBoYXNoIGZyb20gcG9zc2libGUgcGFzc2VkIGV4dGVybmFsc1xuICAgICAgICAgIHVybC5oYXNoID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGhhc2hlc01hcCA9IE9iamVjdC5rZXlzKGhhc2hlc01hcCkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGhhc2gpIHtcbiAgICAgIHZhciB1cmwgPSBuZXcgVVJMKGhhc2hlc01hcFtoYXNoXSwgbG9jYXRpb24pO1xuICAgICAgdXJsLnNlYXJjaCA9ICcnO1xuXG4gICAgICByZXN1bHRbaGFzaF0gPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuXG4gICAgZXh0ZXJuYWxzID0gZXh0ZXJuYWxzLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHVybCA9IG5ldyBVUkwocGF0aCwgbG9jYXRpb24pO1xuICAgICAgdXJsLmhhc2ggPSAnJztcblxuICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQWxsTm9ybWFsaXplZChjYWNoZSwgcmVxdWVzdHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWxsb3dMb2FkZXJzID0gb3B0aW9ucy5hbGxvd0xvYWRlcnMgIT09IGZhbHNlO1xuICAgIHZhciBidXN0VmFsdWUgPSBvcHRpb25zICYmIG9wdGlvbnMuYnVzdDtcbiAgICB2YXIgcmVxdWVzdEluaXQgPSBvcHRpb25zLnJlcXVlc3QgfHwge1xuICAgICAgY3JlZGVudGlhbHM6ICdvbWl0JyxcbiAgICAgIG1vZGU6ICdjb3JzJ1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICBpZiAoYnVzdFZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3QgPSBhcHBseUNhY2hlQnVzdChyZXF1ZXN0LCBidXN0VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmV0Y2gocmVxdWVzdCwgcmVxdWVzdEluaXQpLnRoZW4oZml4UmVkaXJlY3RlZFJlc3BvbnNlKTtcbiAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7XG4gICAgICBpZiAocmVzcG9uc2VzLnNvbWUoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2s7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXcm9uZyByZXNwb25zZSBzdGF0dXMnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRyYWN0ZWQgPSBbXTtcbiAgICAgIHZhciBhZGRBbGwgPSByZXNwb25zZXMubWFwKGZ1bmN0aW9uIChyZXNwb25zZSwgaSkge1xuICAgICAgICBpZiAoYWxsb3dMb2FkZXJzKSB7XG4gICAgICAgICAgZXh0cmFjdGVkLnB1c2goZXh0cmFjdEFzc2V0c1dpdGhMb2FkZXJzKHJlcXVlc3RzW2ldLCByZXNwb25zZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlLnB1dChyZXF1ZXN0c1tpXSwgcmVzcG9uc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChleHRyYWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBjb3B5T2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICAgIG5ld09wdGlvbnMuYWxsb3dMb2FkZXJzID0gZmFsc2U7XG5cbiAgICAgICAgICB2YXIgd2FpdEFsbCA9IGFkZEFsbDtcblxuICAgICAgICAgIGFkZEFsbCA9IFByb21pc2UuYWxsKGV4dHJhY3RlZCkudGhlbihmdW5jdGlvbiAoYWxsKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFjdGVkUmVxdWVzdHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIGFsbCk7XG5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgd2FpdEFsbCA9IHdhaXRBbGwuY29uY2F0KGFkZEFsbE5vcm1hbGl6ZWQoY2FjaGUsIGV4dHJhY3RlZFJlcXVlc3RzLCBuZXdPcHRpb25zKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0QWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZEFsbCA9IFByb21pc2UuYWxsKGFkZEFsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRBbGw7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0QXNzZXRzV2l0aExvYWRlcnMocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICB2YXIgYWxsID0gT2JqZWN0LmtleXMobG9hZGVyc01hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBsb2FkZXIgPSBsb2FkZXJzTWFwW2tleV07XG5cbiAgICAgIGlmIChsb2FkZXIuaW5kZXhPZihyZXF1ZXN0KSAhPT0gLTEgJiYgbG9hZGVyc1trZXldKSB7XG4gICAgICAgIHJldHVybiBsb2FkZXJzW2tleV0ocmVzcG9uc2UuY2xvbmUoKSk7XG4gICAgICB9XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gISFhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFsbCkudGhlbihmdW5jdGlvbiAoYWxsKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBhbGwpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hDYWNoZU1hcChyZXF1ZXN0KSB7XG4gICAgdmFyIHVybFN0cmluZyA9IHJlcXVlc3QudXJsO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHVybFN0cmluZyk7XG5cbiAgICB2YXIgcmVxdWVzdFR5cGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICByZXF1ZXN0VHlwZSA9ICduYXZpZ2F0ZSc7XG4gICAgfSBlbHNlIGlmICh1cmwub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgIHJlcXVlc3RUeXBlID0gJ3NhbWUtb3JpZ2luJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdFR5cGUgPSAnY3Jvc3Mtb3JpZ2luJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlTWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcCA9IGNhY2hlTWFwc1tpXTtcblxuICAgICAgaWYgKCFtYXApIGNvbnRpbnVlO1xuICAgICAgaWYgKG1hcC5yZXF1ZXN0VHlwZXMgJiYgbWFwLnJlcXVlc3RUeXBlcy5pbmRleE9mKHJlcXVlc3RUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdTdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0eXBlb2YgbWFwLm1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5ld1N0cmluZyA9IG1hcC5tYXRjaCh1cmwsIHJlcXVlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UobWFwLm1hdGNoLCBtYXAudG8pO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3U3RyaW5nICYmIG5ld1N0cmluZyAhPT0gdXJsU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXdTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlc01hdGNoKHJlcXVlc3QsIGNhY2hlTmFtZSkge1xuICByZXR1cm4gY2FjaGVzLm1hdGNoKHJlcXVlc3QsIHtcbiAgICBjYWNoZU5hbWU6IGNhY2hlTmFtZVxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmIChpc05vdFJlZGlyZWN0ZWRSZXNwb25zZSgpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLy8gRml4IGFscmVhZHkgY2FjaGVkIHJlZGlyZWN0ZWQgcmVzcG9uc2VzXG4gICAgcmV0dXJuIGZpeFJlZGlyZWN0ZWRSZXNwb25zZShyZXNwb25zZSkudGhlbihmdW5jdGlvbiAoZml4ZWRSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIGNhY2hlcy5vcGVuKGNhY2hlTmFtZSkudGhlbihmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnB1dChyZXF1ZXN0LCBmaXhlZFJlc3BvbnNlKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZml4ZWRSZXNwb25zZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KVxuICAvLyBSZXR1cm4gdm9pZCBpZiBlcnJvciBoYXBwZW5lZCAoY2FjaGUgbm90IGZvdW5kKVxuICBbJ2NhdGNoJ10oZnVuY3Rpb24gKCkge30pO1xufVxuXG5mdW5jdGlvbiBhcHBseUNhY2hlQnVzdChhc3NldCwga2V5KSB7XG4gIHZhciBoYXNRdWVyeSA9IGFzc2V0LmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gIHJldHVybiBhc3NldCArIChoYXNRdWVyeSA/ICcmJyA6ICc/JykgKyAnX191bmNhY2hlPScgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50c1VSTHMoKSB7XG4gIGlmICghc2VsZi5jbGllbnRzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cblxuICByZXR1cm4gc2VsZi5jbGllbnRzLm1hdGNoQWxsKHtcbiAgICBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlXG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNsaWVudHMpIHtcbiAgICBpZiAoIWNsaWVudHMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGNsaWVudCkge1xuICAgICAgdmFyIHVybCA9IG5ldyBVUkwoY2xpZW50LnVybCk7XG4gICAgICB1cmwuc2VhcmNoID0gJyc7XG4gICAgICB1cmwuaGFzaCA9ICcnO1xuICAgICAgdmFyIHVybFN0cmluZyA9IHVybC50b1N0cmluZygpO1xuXG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0LmluZGV4T2YodXJsU3RyaW5nKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godXJsU3RyaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc05hdmlnYXRlUmVxdWVzdChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScgfHwgcmVxdWVzdC5oZWFkZXJzLmdldCgnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cycpIHx8IChyZXF1ZXN0LmhlYWRlcnMuZ2V0KCdBY2NlcHQnKSB8fCAnJykuaW5kZXhPZigndGV4dC9odG1sJykgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc05vdFJlZGlyZWN0ZWRSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5yZWRpcmVjdGVkIHx8ICFyZXNwb25zZS5vayB8fCByZXNwb25zZS50eXBlID09PSAnb3BhcXVlcmVkaXJlY3QnO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3N3LXByZWNhY2hlL3B1bGwvMjQxL2ZpbGVzI2RpZmYtM2VlOTA2MGRjN2EzMTJjNmE4MjJjYWM2M2E4YzYzMGJSODVcbmZ1bmN0aW9uIGZpeFJlZGlyZWN0ZWRSZXNwb25zZShyZXNwb25zZSkge1xuICBpZiAoaXNOb3RSZWRpcmVjdGVkUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gIH1cblxuICB2YXIgYm9keSA9ICdib2R5JyBpbiByZXNwb25zZSA/IFByb21pc2UucmVzb2x2ZShyZXNwb25zZS5ib2R5KSA6IHJlc3BvbnNlLmJsb2IoKTtcblxuICByZXR1cm4gYm9keS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShkYXRhLCB7XG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvcHlPYmplY3Qob3JpZ2luYWwpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9yaWdpbmFsKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSBvcmlnaW5hbFtrZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAodGl0bGUsIGFzc2V0cykge1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCdbU1ddOicsIHRpdGxlKTtcblxuICBhc3NldHMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICBjb25zb2xlLmxvZygnQXNzZXQ6JywgYXNzZXQpO1xuICB9KTtcblxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG4gICAgICAgIFdlYnBhY2tTZXJ2aWNlV29ya2VyKF9fd3BvLCB7XG5sb2FkZXJzOiB7fSxcbmNhY2hlTWFwczogW10sXG59KTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9lbXB0eS1lbnRyeS5qc1wiKVxuICAgICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29mZmxpbmUtcGx1Z2luL2xpYi9taXNjL3N3LWxvYWRlci5qcz9qc29uPSU3QiUyMmRhdGFfdmFyX25hbWUlMjIlM0ElMjJfX3dwbyUyMiUyQyUyMmxvYWRlcnMlMjIlM0ElNUIlNUQlMkMlMjJjYWNoZU1hcHMlMjIlM0ElNUIlNUQlN0QhLi9+L29mZmxpbmUtcGx1Z2luL3RwbHMvZW1wdHktZW50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);